# Programming Language: Python
# Project Type: Multiplayer Chess Game
# Key Functionalities: Multiplayer chess gameplay, move validation and animation, timer updates
# Target Users: Developers maintaining or extending the Chess application
# Code Style: PEP8 with Google-style docstrings and inline comments

"""
This file is a part of the Chess application.
It manages the chess gameplay for the multiplayer section of the application.
"""

import time
import pygame

# Importing all necessary gameplay functions and classes from chess.lib.
# See [chess/lib/__init__.py](Source/chess/lib/__init__.py) for more details.
from chess.lib import (
    start, convertMoves, isOccupied, isValidMove, getPromote, animate,
    updateTimer, makeMove, encode, undo, prompt, showScreen, showClock,
    getTime, saveGame
)

# run main code for chess
def main(win, mode, timer, load, movestr=""):
    """Run the main loop for multiplayer chess.

    Initializes the game board and user interface, processes player input for
    piece movement, handles timing logic, and manages game state for local
    multiplayer chess sessions.

    Args:
        win (pygame.Surface): The display surface where gameplay is rendered.
        mode (str): The timer mode or time control setting for the match.
        timer (list or None): A list containing time data for both players,
            or None if no timer is used.
        load (dict): A dictionary of user preferences and settings.
        movestr (str, optional): Existing moves in algebraic notation. Defaults to "".

    Returns:
        int: A status code indicating how gameplay ended:
             - 0 if the user quits the application
             - 1 if the user navigates back to the main menu
             (other codes may be used by the application for advanced scenarios)
    """
    # Initialize the game environment and resources using [`start`](Source/chess/lib/core.py).
    start(win, load)
    
    # Split the initial moves string into a list to allow resume of an ongoing game.
    moves = movestr.split()

    # Convert existing moves into the current board state.
    side, board, flags = convertMoves(moves)

    # A Pygame clock to manage frame rate for consistent gameplay speed.
    clock = pygame.time.Clock()

    # Track current and previous selection for piece movement on the board.
    sel = prevsel = [0, 0]

    # Convert the timer tuple/list into a mutable list, if provided.
    if timer is not None:
        timer = list(timer)

    # Main event-processing loop for multiplayer chess gameplay.
    while True:
        # Record the loop’s start time to calculate move duration for the clock.
        looptime = getTime()
        clock.tick(25)  # Limit the frame rate to 25 FPS for smooth rendering.
        
        # Tracks the total paused time (e.g., for prompts), applied to the clock.
        timedelta = 0

        # Process all events generated by Pygame.
        for event in pygame.event.get():
            # Quit event: user requests closing the entire application.
            if event.type == pygame.QUIT:
                starttime = getTime()
                # Show a prompt to confirm quitting. See [`prompt`](Source/chess/lib/gui.py).
                if prompt(win):
                    return 0
                timedelta += getTime() - starttime

            # Handle mouse button presses:
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos

                # Check if the user clicked the top-right area, potentially going back to main menu.
                if 460 < x < 500 and 0 < y < 50:
                    starttime = getTime()
                    if prompt(win):
                        return 1
                    timedelta += getTime() - starttime

                # Check if the user clicked inside the 8x8 board area.
                if 50 < x < 450 and 50 < y < 450:
                    # Convert pixel coordinates on screen to board coordinates.
                    x, y = x // 50, y // 50

                    # If the board is flipped for the second player’s perspective,
                    # invert the coordinates accordingly.
                    if load["flip"] and side:
                        x, y = 9 - x, 9 - y

                    # Play an audible click if the clicked square is occupied by a piece.
                    # See [`sound.play_click`](Source/tools/sound.py).
                    if isOccupied(side, board, [x, y]):
                        sound.play_click(load)

                    prevsel = sel
                    sel = [x, y]

                    # If the selected move is valid, handle the move sequence.
                    if isValidMove(side, board, flags, prevsel, sel):
                        starttime = getTime()

                        # Check for pawn promotion choice.
                        promote = getPromote(win, side, board, prevsel, sel)

                        # Animate the piece movement on screen for a polished, visual effect.
                        animate(win, side, board, prevsel, sel, load)
                        timedelta += getTime() - starttime

                        # Update the timer (if any) for the current player.
                        timer = updateTimer(side, mode, timer)

                        # Apply the move to board state and record it in the move list.
                        side, board, flags = makeMove(
                            side, board, prevsel, sel, flags, promote
                        )
                        moves.append(encode(prevsel, sel, promote))

                else:
                    # User clicked outside the board; reset selection.
                    sel = [0, 0]

                    # Check if the user clicked in the save/exit area.
                    if 350 < x < 500 and 460 < y < 490:
                        starttime = getTime()
                        # Prompt to save the game or return to the main menu.
                        if prompt(win, saveGame(moves, mode=mode, timer=timer)):
                            return 1
                        timedelta += getTime() - starttime

                    # If user clicked the top-left area and allows undo from preferences.
                    elif 0 < x < 80 and 0 < y < 50 and load["allow_undo"]:
                        # Undo the last move and revert board state.
                        moves = undo(moves)
                        side, board, flags = convertMoves(moves)

        # Update the display with the current board state, piece positions, and highlights.
        # See [`showScreen`](Source/chess/lib/gui.py).
        showScreen(win, side, board, flags, sel, load)

        # Update the chess clock display with elapsed time and paused interval.
        # See [`showClock`](Source/chess/lib/gui.py).
        timer = showClock(win, side, mode, timer, looptime, timedelta)